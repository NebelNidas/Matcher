package matcher.ir.api.env;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Stream;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import matcher.ir.api.identity.Identity;
import matcher.ir.api.instance.FieldInstance;
import matcher.ir.api.instance.MethodArgInstance;
import matcher.ir.api.instance.MethodInstance;
import matcher.ir.api.instance.MethodVarInstance;
import matcher.ir.api.instance.extensible.ClassInstance;

/**
 * {@link ClassEnv} capable of auto-generating "phantom" instance shells if missing from the classpath.
 * This helps for analyzing hierarchies when certain (smaller) parts are missing.
 */
public interface PhantomCapableClassEnv<
		C extends ClassInstance,
		F extends FieldInstance,
		M extends MethodInstance,
		MA extends MethodArgInstance,
		MV extends MethodVarInstance> extends ClassEnv {
	/**
	 * @return Internal names of all contained "real" (non-autogenerated) classes.
	 */
	@NotNull
	Set<String> getRealClassNames();

	/**
	 * @return Internal names of all auto-generated classes.
	 * For consumers unmodifiable, but implementors are free to add classes at any time.
	 * Already added classes can't be removed though.
	 */
	@NotNull
	Set<String> getPhantomClassNames();

	/**
	 * @return Concatenation of {@link #getRealClassNames()} and {@link #getPhantomClassNames()}.
	 */
	@Override
	@NotNull
	default Set<String> getClassNames() {
		Set<String> ret = new HashSet<>(getRealClassNames());
		Set<String> phantoms = getPhantomClassNames();

		synchronized (phantoms) {
			ret.addAll(phantoms);
		}

		return ret;
	}

	/**
	 * @return Stream over all contained real {@link ClassInstance}s.
	 * In contrast to {@link #getRealClasses}, this method loads lazily.
	 */
	@NotNull
	Stream<C> streamRealClasses();

	/**
	 * @return Stream over all auto-generated {@link ClassInstance}s.
	 * In contrast to {@link #getPhantomClasses}, this method loads lazily.
	 */
	@NotNull
	Stream<C> streamPhantomClasses();

	/**
	 * @return Concatenation of {@link #streamRealClasses()} and {@link #streamPhantomClasses()}.
	 */
	@Override
	@NotNull
	default Stream<C> streamClasses() {
		return Stream.concat(streamRealClasses(), streamPhantomClasses());
	}

	/**
	 * @return All contained real {@link ClassInstance}s.
	 * Warning: This method loads content eagerly, use the lazy {@link #streamRealClasses()} instead where possible!
	 */
	@NotNull
	Collection<C> getRealClasses();

	/**
	 * @return All auto-generated {@link ClassInstance}s up to this point in time.
	 */
	@NotNull
	Collection<C> getPhantomClasses();

	/**
	 * @return Concatenation of {@link #getRealClasses()} and {@link #getPhantomClasses()}.
	 */
	@Override
	@NotNull
	default Collection<C> getClasses() {
		Collection<C> ret = new HashSet<>(getRealClasses());
		Collection<C> phantoms = getPhantomClasses();

		synchronized (phantoms) {
			ret.addAll(phantoms);
		}

		return ret;
	}

	/**
	 * @return Class with passed internal name, if present.
	 */
	@Nullable
	C getClassByName(@NotNull String internalName);

	/**
	 * @return Class with corresponding identity, if present.
	 */
	@Nullable
	C getRealClassByIdentity(@NotNull Identity clsIdentity);

	@Nullable
	F getRealFieldByIdentity(@NotNull Identity fldIdentity);

	@Nullable
	M getRealMethodByIdentity(@NotNull Identity mthIdentity);

	@Nullable
	MA getRealMethodArgByIdentity(@NotNull Identity argIdentity);

	@Nullable
	MV getRealMethodVarByIdentity(@NotNull Identity varIdentity);
}
